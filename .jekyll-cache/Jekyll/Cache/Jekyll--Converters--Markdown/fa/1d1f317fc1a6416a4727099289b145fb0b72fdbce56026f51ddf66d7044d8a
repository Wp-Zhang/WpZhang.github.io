I"ǲ<h2 id="用线性回归找到最佳拟合直线">用线性回归找到最佳拟合直线</h2>

<h3 id="理论">理论</h3>

<p>将预测目标表示为由特征组成的线性回归方程，每个特征对应一个系数。当有新数据输入时将新数据的特征乘上对应的系数求和得到最终的预测结果。</p>

<p>通过不断调整系数向量，使预测结果与实际值的误差尽量小，最终得到最优系数。</p>

<p>计算误差的常用方法为计算平方误差：<img src="http://latex.codecogs.com/gif.latex?%5Csum%5Em_%7Bi%3D1%7D%28y_i-x_i%5ETw%29%5E2" />，可用矩阵表示为<img src="http://latex.codecogs.com/gif.latex?%28y-Xw%29%5ET%28y-Xw%29" />。
当矩阵X可以求逆时，将均方差公式求导可以得出公式：<img src="http://latex.codecogs.com/gif.latex?%5Cwidehat%7Bw%7D%20%3D%20%28X%5ETX%29%5E%7B-1%7DX%5ETy" />，可以根据公式估计w的最优解。这就是最小二乘法。</p>

<h3 id="算法实现">算法实现</h3>

<h4 id="载入数据">载入数据</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="n">fileName</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">dataMat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
        <span class="n">dataMat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="s">'float'</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dataMat</span><span class="p">,</span> <span class="n">labels</span>
</code></pre></div></div>

<h4 id="计算最佳拟合直线">计算最佳拟合直线</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">standRegres</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">):</span>
    <span class="n">yMat</span> <span class="o">=</span> <span class="n">yArr</span><span class="p">.</span><span class="n">T</span>
    <span class="n">xTx</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">xMat</span>
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">det</span><span class="p">(</span><span class="n">xTx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 矩阵无法求逆
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"This matrix is singular, cannot do inverse."</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">xTx</span><span class="p">.</span><span class="n">I</span> <span class="o">@</span> <span class="n">xMat</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">yMat</span>
    <span class="k">return</span> <span class="n">w</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span> <span class="o">=</span> <span class="n">loadDataSet</span><span class="p">(</span><span class="s">'data/ex0.txt'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">standRegres</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>matrix([[3.00774324],
        [1.69532264]])
</code></pre></div></div>

<h4 id="绘制拟合曲线">绘制拟合曲线</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plotRegresLine</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yMat</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xMat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yMat</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span><span class="mi">0</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 将X和Y降维成一位数组后绘制散点图
</span>    <span class="c1"># 将X排序后绘制预测直线
</span>    <span class="n">xCopy</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">xCopy</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">yHat</span> <span class="o">=</span> <span class="n">xCopy</span> <span class="o">@</span> <span class="n">w</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xCopy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">yHat</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wHat</span> <span class="o">=</span> <span class="n">standRegres</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">)</span>
<span class="n">plotRegresLine</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="n">wHat</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/media/editor/output_17_0_20190401234014801681.png" alt="" /></p>

<p>可以通过预测结果和实际值的相关系数来判断模型的预测效果。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yHat</span> <span class="o">=</span> <span class="n">xMat</span> <span class="o">@</span> <span class="n">wHat</span>
<span class="n">np</span><span class="p">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">yHat</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">yArr</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([[1.        , 0.98647356],
       [0.98647356, 1.        ]])
</code></pre></div></div>

<p>可见在这个案例中预测值和实际值相关系数为0.987,模型表现效果较好。</p>

<h2 id="局部加权线性回归">局部加权线性回归</h2>

<h3 id="理论-1">理论</h3>

<p>线性回归的很容易出现欠拟合现象，因为它求的是具有最小均方误差的无偏估计。如果允许在估计时引入一些偏差，可能可以降低预测的均方误差。其中一个方法就是局部加权线性回归。</p>

<p>这个方法与KNN相似，每次预测时取出目标预测点附近的数据子集，给数据子集中的每个点赋予一定的权重然后基于最小均方差来进行普通的回归。</p>

<p>回归系数的计算公式：<img src="http://latex.codecogs.com/gif.latex?%5Cwidehat%7Bw%7D%20%3D%20%28X%5ETWX%29%5E%7B-1%7DX%5ETWy" />，其中W是权重矩阵</p>

<p>局部加权线性回归使用“核”来对附近的点赋予更高的权重。常用高斯核：<img src="http://latex.codecogs.com/gif.latex?w%28i%2Ci%29%20%3D%20exp%5Cleft%28%5Cfrac%7B%5Cleft%7Cx%5E%7B%28i%29%7D-x%5Cright%7C%7D%7B-2k%5E2%7D%5Cright%29" />根据公式可以看出：点x与点x(i)越近，w(i,i)将会越大。公式中的k需要自行设置，当k越小，能用于训练回归模型的数据量就越小。</p>

<h3 id="算法实现-1">算法实现</h3>

<h4 id="利用加权线性回归预测单条数据">利用加权线性回归预测单条数据</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lwlr</span><span class="p">(</span><span class="n">testPoint</span><span class="p">,</span> <span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="n">yMat</span> <span class="o">=</span> <span class="n">yArr</span><span class="p">.</span><span class="n">T</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">((</span><span class="n">m</span><span class="p">)))</span>  <span class="c1"># 初始化权重矩阵为单位矩阵
</span>    <span class="c1"># 使用高斯核计算权重矩阵
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">diffMat</span> <span class="o">=</span> <span class="n">testPoint</span> <span class="o">-</span> <span class="n">xMat</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">diffMat</span><span class="o">*</span><span class="n">diffMat</span><span class="p">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1">#weights[j,j] = np.exp(np.linalg.det(diffMat) / (-2*k**2))
</span>    <span class="n">xTx</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">weights</span> <span class="o">@</span> <span class="n">xMat</span>
    <span class="c1"># 矩阵不可逆
</span>    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">det</span><span class="p">(</span><span class="n">xTx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"This matrix is singular, cannot do inverse."</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">xTx</span><span class="p">.</span><span class="n">I</span> <span class="o">@</span> <span class="n">xMat</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">weights</span> <span class="o">@</span> <span class="n">yMat</span>
    <span class="k">return</span> <span class="n">testPoint</span> <span class="o">@</span> <span class="n">result</span>
</code></pre></div></div>

<h4 id="利用加权线性回归预测数据集">利用加权线性回归预测数据集</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lwlrTest</span><span class="p">(</span><span class="n">testArr</span><span class="p">,</span> <span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">yHat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">yHat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lwlr</span><span class="p">(</span><span class="n">testArr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">yHat</span>
</code></pre></div></div>

<h4 id="绘制拟合曲线-1">绘制拟合曲线</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plotLine</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">fig</span><span class="p">,</span><span class="n">plot_position</span><span class="p">):</span>
    <span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span> <span class="o">=</span> <span class="n">loadDataSet</span><span class="p">(</span><span class="s">'data/ex0.txt'</span><span class="p">)</span>
    <span class="n">yHat</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">plot_position</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xMat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yArr</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span><span class="mi">0</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 将X和Y降维成一位数组后绘制散点图
</span>    <span class="c1"># 将X排序后绘制预测直线
</span>    <span class="n">sortedIndex</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">].</span><span class="n">argsort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">xCopy</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">copy</span><span class="p">()[</span><span class="n">sortedIndex</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xCopy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">yHat</span><span class="p">[</span><span class="n">sortedIndex</span><span class="p">])</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="n">plotLine</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="mi">311</span><span class="p">)</span>
<span class="n">plotLine</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="mi">312</span><span class="p">)</span>
<span class="n">plotLine</span><span class="p">(</span><span class="mf">0.003</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="mi">313</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/media/editor/output_34_0_20190401234028717750.png" alt="" /></p>

<p>可见当k过小时容易发生过拟合现象，原因是考虑了太多噪声。</p>

<h2 id="示例预测鲍鱼的年龄">示例：预测鲍鱼的年龄</h2>

<h3 id="读取数据">读取数据</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abX</span><span class="p">,</span> <span class="n">abY</span> <span class="o">=</span> <span class="n">loadDataSet</span><span class="p">(</span><span class="s">'data/abalone.txt'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="训练模型">训练模型</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yHat01</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">],</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">yHat1</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">yHat10</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="计算误差">计算误差</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rssError</span><span class="p">(</span><span class="n">yArr</span><span class="p">,</span> <span class="n">yHat</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">yArr</span> <span class="o">-</span> <span class="n">yHat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">).</span><span class="nb">sum</span><span class="p">()</span>
</code></pre></div></div>

<p>训练数据集误差计算</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rssError</span><span class="p">(</span><span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yHat01</span><span class="p">)</span>
<span class="n">rssError</span><span class="p">(</span><span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yHat1</span><span class="p">)</span>
<span class="n">rssError</span><span class="p">(</span><span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yHat10</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>56.81549669032892

429.8905618702056

549.1181708826584
</code></pre></div></div>

<p>测试数据将误差计算</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yHat01</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">abX</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">199</span><span class="p">,:],</span> <span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">],</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">yHat1</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">abX</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">199</span><span class="p">,:],</span> <span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">yHat10</span> <span class="o">=</span> <span class="n">lwlrTest</span><span class="p">(</span><span class="n">abX</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">199</span><span class="p">,:],</span> <span class="n">abX</span><span class="p">[:</span><span class="mi">99</span><span class="p">,:],</span> <span class="n">abY</span><span class="p">[:,:</span><span class="mi">99</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rssError</span><span class="p">(</span><span class="n">abY</span><span class="p">[:,</span><span class="mi">100</span><span class="p">:</span><span class="mi">199</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yHat01</span><span class="p">)</span>
<span class="n">rssError</span><span class="p">(</span><span class="n">abY</span><span class="p">[:,</span><span class="mi">100</span><span class="p">:</span><span class="mi">199</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yHat1</span><span class="p">)</span>
<span class="n">rssError</span><span class="p">(</span><span class="n">abY</span><span class="p">[:,</span><span class="mi">100</span><span class="p">:</span><span class="mi">199</span><span class="p">].</span><span class="n">flatten</span><span class="p">().</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yHat10</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>40659.27596541478

573.5261441898057

517.5711905382693
</code></pre></div></div>

<p>可见k越小在训练集上表现越好，但是过拟合严重，在测试集上表现很差</p>

<h2 id="缩减系数来理解数据">缩减系数来“理解”数据</h2>

<p>当数据的特征比样本点还多时，用之前的最小二乘法求系数矩阵时由于X不是满秩矩阵，在求逆时会出现问题，因此引入了接下来的方法。</p>

<h3 id="岭回归">岭回归</h3>

<h4 id="理论-2">理论</h4>

<p>简单来说，岭回归就是在矩阵$X^TX$上加入一个<img src="http://latex.codecogs.com/gif.latex?%24%5Clambda%20I%24" />使得矩阵非奇异，从而可以进行求逆运算。矩阵I是一个mxm的单位矩阵，λ的数值由用户自行设置。</p>

<p>因此，回归系数计算公式变为：<img src="http://latex.codecogs.com/gif.latex?%5Cwidehat%7Bw%7D%20%3D%20%28X%5ETX&plus;%5Clambda%20I%29%5E%7B-1%7DX%5ETy" /></p>

<p>岭回归最初用来处理特征数多余样本数的情况，现在也用于在估计中加入偏差从而获得更好的估计。引入的λ作为惩罚项能够减少不重要的参数。</p>

<p>与之前相同，通过预测误差最小化求得λ。</p>

<h4 id="算法实现-2">算法实现</h4>

<h5 id="求回归系数">求回归系数</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ridgeRegress</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yMat</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
    <span class="n">xTx</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">xMat</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">xTx</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">lam</span>
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">det</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"This matrix is singular, cannot do inverse"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">I</span> <span class="o">@</span> <span class="n">xMat</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">yMat</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h5 id="岭回归预测">岭回归预测</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ridgeTest</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">):</span>
    <span class="n">yMat</span> <span class="o">=</span> <span class="n">yArr</span><span class="p">.</span><span class="n">T</span>
    <span class="c1"># 数据标准化
</span>    <span class="n">yMean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yMat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">yMat</span> <span class="o">=</span> <span class="n">yMat</span> <span class="o">-</span> <span class="n">yMean</span>
    <span class="n">xMeans</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">xVar</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">var</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">xMat</span> <span class="o">=</span> <span class="p">(</span><span class="n">xMat</span> <span class="o">-</span> <span class="n">xMeans</span><span class="p">)</span> <span class="o">/</span> <span class="n">xVar</span>
    
    <span class="n">numTestPts</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># 测试的λ个数
</span>    <span class="n">wMat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numTestPts</span><span class="p">,</span><span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># 存储所有λ对应的回归系数
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numTestPts</span><span class="p">):</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">ridgeRegress</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yMat</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">wMat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">ws</span><span class="p">.</span><span class="n">T</span>
    
    <span class="k">return</span> <span class="n">wMat</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abX</span><span class="p">,</span> <span class="n">abY</span> <span class="o">=</span> <span class="n">loadDataSet</span><span class="p">(</span><span class="s">'data/abalone.txt'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ridgeWeights</span> <span class="o">=</span> <span class="n">ridgeTest</span><span class="p">(</span><span class="n">abX</span><span class="p">,</span> <span class="n">abY</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="不同lambda模型效果比较">不同lambda模型效果比较</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ridgeWeights</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"log(λ)"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/media/editor/output_65_2_20190401234053872011.png" alt="" /></p>

<h3 id="lasso">lasso</h3>

<p>与岭回归类似，lasso也对回归系数做了限定：<img src="http://latex.codecogs.com/gif.latex?%5Csum%5En_%7Bk%3D1%7D%5Cleft%7Cw_k%5Cright%7C%5Cleqslant%5Clambda" /></p>

<p>通过这个限制条件，当λ足够小的时候，部分系数会被缩减到0，缩减特征的同时帮助我们更好地理解数据。</p>

<p>虽然效果很好，但是极大地增加了计算复杂度。下面的方法更为简单。</p>

<h3 id="前向逐步回归">前向逐步回归</h3>

<h4 id="理论-3">理论</h4>

<p>前向逐步回归可以得到与lasso差不多的效果但更加简单。它属于一种贪心算法即每一步都尽可能减小误差。初始时所有权重为1，每一步所做的决策是对某个权重增加或减少一个很小的值</p>

<h4 id="算法实现-3">算法实现</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">regularize</span><span class="p">(</span><span class="n">xMat</span><span class="p">):</span>
    <span class="n">inMat</span> <span class="o">=</span> <span class="n">xMat</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">inMeans</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inMat</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">inVar</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">var</span><span class="p">(</span><span class="n">inMat</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">inMat</span> <span class="o">=</span> <span class="p">(</span><span class="n">inMat</span> <span class="o">-</span> <span class="n">inMeans</span><span class="p">)</span><span class="o">/</span><span class="n">inVar</span>
    <span class="k">return</span> <span class="n">inMat</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stageWise</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">numIt</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="s">"""
    eps: 权重每次改变的步长
    numIt: 迭代次数
    """</span>
    <span class="n">yMat</span> <span class="o">=</span> <span class="n">yArr</span><span class="p">.</span><span class="n">T</span>
    <span class="c1"># 数据标准化
</span>    <span class="n">yMean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yMat</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">yMat</span> <span class="o">=</span> <span class="n">yMat</span> <span class="o">-</span> <span class="n">yMean</span>
    <span class="n">xMat</span> <span class="o">=</span> <span class="n">regularize</span><span class="p">(</span><span class="n">xMat</span><span class="p">)</span>
    <span class="c1"># 前向逐步回归
</span>    <span class="n">returnMat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numIt</span><span class="p">,</span><span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numIt</span><span class="p">):</span>
        <span class="c1">#print(ws.T)
</span>        <span class="n">wsMax</span> <span class="o">=</span> <span class="n">ws</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lowestError</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>  <span class="c1"># 初始化最小误差为无穷大
</span>        <span class="c1"># 逐步修改每个特征的权重
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xMat</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># 权重增或减
</span>            <span class="k">for</span> <span class="n">sign</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">wsTest</span> <span class="o">=</span> <span class="n">ws</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">wsTest</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">sign</span>
                <span class="n">yTest</span> <span class="o">=</span> <span class="n">xMat</span> <span class="o">@</span> <span class="n">wsTest</span>
                <span class="c1"># 计算误差
</span>                <span class="n">rssE</span> <span class="o">=</span> <span class="n">rssError</span><span class="p">(</span><span class="n">yMat</span><span class="p">.</span><span class="n">A</span><span class="p">,</span> <span class="n">yTest</span><span class="p">.</span><span class="n">A</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rssE</span> <span class="o">&lt;</span> <span class="n">lowestError</span><span class="p">:</span>
                    <span class="n">lowestError</span> <span class="o">=</span> <span class="n">rssE</span>
                    <span class="n">wsMax</span> <span class="o">=</span> <span class="n">wsTest</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">wsMax</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">returnMat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">ws</span><span class="p">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">returnMat</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span> <span class="o">=</span> <span class="n">loadDataSet</span><span class="p">(</span><span class="s">'data/abalone.txt'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weights</span> <span class="o">=</span> <span class="n">stageWise</span><span class="p">(</span><span class="n">xMat</span><span class="p">,</span> <span class="n">yArr</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/media/editor/output_77_1_20190402122318183132.png" alt="" /></p>

<p>可见当迭代次数到达600后，权重趋近于一个稳定值。这样的图像充分体现了模型的好处。</p>
:ET